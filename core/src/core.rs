use anyhow::{bail, Result};
use convert_case::{Case, Casing};
use regex::Regex;
use std::{collections::HashSet, env};

use lazy_static::lazy_static;

lazy_static! {
    static ref ICONS_REGEX: Regex =
        Regex::new(r#"\.?(\S+)\s*:\s*before\s*\{\s*content:\s*["']\\?(\S+)["']"#).unwrap();
    static ref FONT_REGEX: Regex = Regex::new(r#"font-family:\s*['"]([^'"]*)"#).unwrap();
}

pub fn convert(class_name: &str, css: &str, package: Option<&str>) -> Result<String> {
    let font = find_font(css)?;
    let icons = find_icons(css);
    Ok(generate_dart(class_name, font, package, &icons))
}

fn generate_dart(
    class_name: &str,
    font_family: &str,
    package: Option<&str>,
    icons: &HashSet<(String, String)>,
) -> String {
    let generated_by = env::var("CARGO_PKG_NAME")
        .map_or(String::new(), |name| format!("\n// Generated by {}", name));

    let mut content = String::new();
    content.push_str(
        format!(
            r#"// **************************************************************************
// GENERATED CODE - DO NOT MODIFY BY HAND{}
// **************************************************************************

// ignore_for_file: lines_longer_than_80_chars

"#,
            generated_by
        )
        .as_str(),
    );
    content.push_str(
        format!(
            r#"import 'package:flutter/widgets.dart';

@staticIconProvider
abstract final class {} {{
  {}._();

  static const String _kFamily = '{}';
"#,
            class_name, class_name, font_family
        )
        .as_str(),
    );
    if package.is_some() {
        content.push_str(
            format!("  static const String _kPackage = '{}';", package.unwrap()).as_str(),
        );
    }

    content.push_str("\n");

    for (name, code) in icons {
        content.push_str(
            format!(
                "  static const IconData {} = IconData(0x{}, fontFamily: _kFamily",
                name, code
            )
            .as_str(),
        );

        if package.is_some() {
            content.push_str(", package: _kPackage");
        }

        content.push_str(");\n");
    }

    content.push_str("}");

    return content;
}

fn find_icons(css: &str) -> HashSet<(String, String)> {
    ICONS_REGEX
        .captures_iter(css)
        .filter_map(|item| {
            item.get(1).zip(item.get(2)).map(|(name, code)| {
                (
                    name.as_str().to_case(Case::Camel),
                    code.as_str().to_string(),
                )
            })
        })
        .collect()
}

fn find_font(css: &str) -> Result<&str> {
    let fonts = FONT_REGEX
        .captures_iter(css)
        .filter_map(|item| item.get(1))
        .map(|item| item.as_str())
        .collect::<HashSet<&str>>();

    match fonts.len() {
        1 => Ok(fonts.iter().next().unwrap()),
        0 => bail!("Font family not found."),
        _ => bail!(
            "Found multiple font families: {}, but only support one of them.",
            fonts.iter().cloned().collect::<Vec<_>>().join(", ")
        ),
    }
}
